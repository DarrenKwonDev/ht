# ht

hash table implementation in C

## theory of hash table

배열에 특정 값을 루프를 돌지 않으며 O(1)으로 찾는 방법 -> 해시 테이블의 등장 과정.

hash table에 저장하는 과정

```c
입력값 -> 해시함수 -> 해시값 -> 소수로 나누기 -> 색인 -> 저장
```

### 색인 추출 및 색인 충돌

`1안. 값을 색인으로 사용하기`  
예를 들면, 724가 배열에 존재하는 지의 여부를 아래처럼 판단.
arr[724] = 1 or 0 (724의 존재 여부)
값이 커짐에 따라 배열 크기도 선형적 증가.
메모리 낭비 심함. 기각.

`2안. 소수로 나눈 값을 색인으로 사용하기`  
예를 들면, [72, 81]을 소수인 7로 나누어 각각 나머지인 2, 4를 색인으로써 사용하자는 것.
중복 색인이 발생하는 문제.

`2안 보완. 색인 충돌 해결 방법`

1. bool 배열(혹은 가능하지 않은 값을 넣은)을 만들어서 이미 찬 곳은 넘고, 빈 곳에 넣는다.
2. 배열이 linked list여서 여러 값을 저장하게 만들자.  
   예를 들어
   idx  
   1 -> [8, 15]  
   2 -> [9, 110]  
   3 -> [3, 22, 45]

### 해시와 해시 충돌

`해시 함수`

-   임의값을 고정된 크기로 출력하는 함수.
-   근본 질문인 '배열에 특정 값을 루프를 돌지 않으며 O(1)으로 찾는 방법'을 위해서는 시간 복잡도가 O(1) 이어야 함.
-   수학적으로 해시 충돌은 발생함. 그러나 최근의 해시 알고리즘은 해시 충돌 확률이 극히 낮으며 특정 조건 하에는 방지 가능.

해시 함수 종류 : 65599, MD, SHA, Argon2, FNV-1 ... 아주 많음. 속도가 빠르면 충돌 확률이 높고 느릴 수록 충돌 확률이 낮음.  
간단한 데이터 구조에는 FNV-1과 같은 빠른 해시 함수가 적합할 수 있고, 보안이 중요한 경우에는 SHA-256과 같은 더 안전한 해시 함수가 필요할 수 있음.

`해시 충돌이 나면?`

선형 탐색으로 빈 곳을 찾아야 함. O(1)을 의도한 해시 테이블이었으나 해시 충돌 발생시 다른 곳을 찾아 이동해야 하므로 O(n)의 선형 탐색이 필요함.  
결국 해시 테이블 자료 구조의 장점을 잃게 됨. 그래서 해시 충돌이 가급적 일어나지 않아야함.

`해시 충돌 해결 방법`

해시 충돌 : 키가 다른데 같은 해시값이 나옴
색인 충돌 : 해시값은 다른데 같은 색인이 나옴

순서 상으로 해시값이 값으면 당연히 색인 충돌도 발생함.  
그러나 해시 충돌 문제를 해결해야 하나? 사실 색인 충돌 해결 방식으로 같이 해결된다.  
하지만 해시 충돌을 방지하면 성능 이득이 있다. 해시가 발생하면 본래 입력값과 해시값 둘 다 알아야 하는데 해시 충돌이 없다면 해시값만 알면 되기 때문이다.

`해시 충돌을 방지할 수 있는 조건?`

데이터가 한정된 경우 (유저 입력을 받아 데이터가 워낙 많이 들어와 충돌 가능성이 있지만 한정된 데이터만으로 해시 함수를 돌리는 경우는 가능)
